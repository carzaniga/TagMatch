// -*- C++ -*-
//
//  This file is part of Siena, a wide-area event notification system.
//  See http://www.inf.usi.ch/carzaniga/siena/
//
//  Authors: Antonio Carzaniga
//  See the file AUTHORS for full details. 
//
//  Copyright (C) 2013 Antonio Carzaniga
//
//  Siena is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//  
//  Siena is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//  
//  You should have received a copy of the GNU General Public License
//  along with Siena.  If not, see <http://www.gnu.org/licenses/>.
//
#include <iostream>
#include <set>

#include "patricia_predicate.hh"
#include "routing.hh"

#ifndef INTERFACES
#define INTERFACES 256U
#endif

using std::set;
using std::cout;
using std::endl;

class match_vector : public match_handler {
public:
	match_vector(): output{0} {};

	virtual bool match(const filter_t & filter, tree_t tree, interface_t ifx) {
		output[ifx] = 1;
		return false;
	}

	void print_results() const {
		for(unsigned int i = 0; i < INTERFACES; ++i)
			if (output[i] != 0) 
				cout << ' ' << i;
		cout << endl;
    }

	void return_results(set<interface_t> & res) const {
		res.clear();
		for(interface_t i = 0; i < INTERFACES; ++i)
			if (output[i] != 0) 
				res.insert(i);
    }

private:
	unsigned char output[INTERFACES];
};

class match_finder : public match_handler {
public:
	match_finder(const filter_t & f): filter(f), found(false) {};

	virtual bool match(const filter_t & f, tree_t t, interface_t i) {
		if (f == filter)
			found = true;
		return found;
	}

	bool result() const {
		return found;
    }

private:
	filter_t filter;
	bool found;
};

bool find_filter(predicate & P, const filter_t & f) {
	match_finder finder(f);
	P.match(f, finder);
	return finder.result();
}

#define BOOST_TEST_MODULE predicate
#define BOOST_TEST_DYN_LINK 1

#include <boost/test/unit_test.hpp>

BOOST_AUTO_TEST_SUITE( patricia_predicate_basics )

BOOST_AUTO_TEST_CASE( add_and_find ) {
	predicate P;

	filter_t f1("001010000110101011000001000100000000011100001110010001101001001111101000000000001110011010010100100010000001011000000100100000001101000110011001001000000000001000111010000000000110000010000110");

	tree_interface_pair tips[2];
	tips[0].assign(1, 2);
	tips[1].assign(1, 3);

	P.add(f1, tips, tips + 2);
	BOOST_CHECK(find_filter(P, f1));

	match_vector v;
	P.match(f1, v);
	std::set<interface_t> res;
	v.return_results(res);
	BOOST_CHECK(res == std::set<interface_t>({2, 3}));
}

BOOST_AUTO_TEST_CASE( add_and_find_multi ) {
	const char * filters[] = {
		"000000000000010000000100000000000000100000001000100000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000001000000000000100000000000001000000000000101001000",
		"000000000000010000000000000000000000100000000000100000000010000000000010010000000000000100010000000000000000100000000000000000000000000000100000000100000010000101000000000110000010000100000010",
		"000000000001000000000001000100000000001000000010000000000000000001000000000000000100000000000000000000000000000010100000010000000011000000010000000010000000000000000010000000001000000000101000",
		"000010000100100000000000001000000100000000000000000000000000000000000000000101000000000000010000000000000000000000000000001000000100000000101000000000000010000000000000010000000000000000000000",
	};

	predicate P;
	P.add(filter_t(filters[0]), 1, 1);
	P.add(filter_t(filters[1]), 1, 2);
	P.add(filter_t(filters[2]), 1, 3);
	P.add(filter_t(filters[3]), 1, 4);

	BOOST_CHECK(find_filter(P, filter_t(filters[0])));
	BOOST_CHECK(find_filter(P, filter_t(filters[1])));
	BOOST_CHECK(find_filter(P, filter_t(filters[2])));
	BOOST_CHECK(find_filter(P, filter_t(filters[3])));
}

BOOST_AUTO_TEST_CASE( add_and_clear ) {
	predicate P;

	filter_t f1("001010000110101011000001000100000000011100001110010001101001001111101000000000001110011010010100100010000001011000000100100000001101000110011001001000000000001000111010000000000110000010000110");

	BOOST_CHECK(!find_filter(P, f1));

	P.add(f1, 1, 3);
	P.add(f1, 1, 2);

	BOOST_CHECK(find_filter(P, f1));

	P.clear();

	BOOST_CHECK(!find_filter(P, f1));
}

BOOST_AUTO_TEST_CASE( add_many_and_find ) {
	predicate P;

	const char * filters[] = {
		"000000000000010000000100000000000000100000001000100000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000001000000000000100000000000001000000000000101001000",
		"000000000000010000000000000000000000100000000000100000000010000000000010010000000000000100010000000000000000100000000000000000000000000000100000000100000010000101000000000110000010000100000010",
		"000000000001000000000001000100000000001000000010000000000000000001000000000000000100000000000000000000000000000010100000010000000011000000010000000010000000000000000010000000001000000000101000",
		"000010000100100000000000001000000100000000000000000000000000000000000000000101000000000000010000000000000000000000000000001000000100000000101000000000000010000000000000010000000000000000000000",
		"000110000010000100100000000000000000000000010000000000001001000000100000000000000000100010000000000000000000000000000000000000101000000000000011000000001000000000000100000000000001001000000010",
		"011000000010000000000000000000000001000000000000000000000000000000000001000010000000000000001000000000000010000000000010000000000000010000000100000000100000000000000000000000000000101000000000",
		"000010000000010000000000000010010000000000000001000100000000000000000000000000010000000000000000100000000000000000000000000000000000000000001000000000000000000000000000000000000000111000000000",
		"000000000000000000000000000000001100000000000000000100000000000000010000000010001000000000000000000000001000000000000000010000000001100000000000000000000000000000000000000000000100000100100001",
		"100000100000000000000010000000000000000000000000000000000010000010000000011010010000000101000000000000000000000000000000001001000000010100000000000000000000000000000000001010001100000000000000",
		"000000000000000100000000100000010000000010000000000010100000000000000000100000000000000000010011000101000000000100000000000001000000000001000000010100100000000100000000000000011000000000000000",
	};

	static const int N = sizeof(filters) / sizeof(const char *);

	for(int i = 0; i < N; ++i) 
		P.add(filter_t(filters[i]), 1, i);

	BOOST_CHECK(find_filter(P, filter_t(filters[0])));
	BOOST_CHECK(find_filter(P, filter_t(filters[1])));
	BOOST_CHECK(find_filter(P, filter_t(filters[2])));
	BOOST_CHECK(find_filter(P, filter_t(filters[3])));
	BOOST_CHECK(find_filter(P, filter_t(filters[4])));
	BOOST_CHECK(find_filter(P, filter_t(filters[5])));
	BOOST_CHECK(find_filter(P, filter_t(filters[6])));
	BOOST_CHECK(find_filter(P, filter_t(filters[7])));
	BOOST_CHECK(find_filter(P, filter_t(filters[8])));
	BOOST_CHECK(find_filter(P, filter_t(filters[9])));

	filter_t fX("100100011010010011111010000000000011100110100101001000100000010001010000110101011000001000100000000011100001100001000111010000000110000001001000000011010001100100010010000000000110000010000110");

	BOOST_CHECK(!find_filter(P, fX));
}

BOOST_AUTO_TEST_CASE( subsets ) {
	predicate P;

	const char * filters[] = {
		"000000000000010000000100000000000000100000001000100000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000001000000000000100000000000001000000000000101001000",
		"000000000000010000000000000000000000100000000000100000000010000000000010010000000000000100010000000000000000100000000000000000000000000000100000000100000010000101000000000110000010000100000010",
		"000000000001000000000001000100000000001000000010000000000000000001000000000000000100000000000000000000000000000010100000010000000011000000010000000010000000000000000010000000001000000000101000",
		"000010000100100000000000001000000100000000000000000000000000000000000000000101000000000000010000000000000000000000000000001000000100000000101000000000000010000000000000010000000000000000000000",
		"000110000010000100100000000000000000000000010000000000001001000000100000000000000000100010000000000000000000000000000000000000101000000000000011000000001000000000000100000000000001001000000010",
		"011000000010000000000000000000000001000000000000000000000000000000000001000010000000000000001000000000000010000000000010000000000000010000000100000000100000000000000000000000000000101000000000",
		"000010000000010000000000000010010000000000000001000100000000000000000000000000010000000000000000100000000000000000000000000000000000000000001000000000000000000000000000000000000000111000000000",
		"000000000000000000000000000000001100000000000000000100000000000000010000000010001000000000000000000000001000000000000000010000000001100000000000000000000000000000000000000000000100000100100001",
		"100000100000000000000010000000000000000000000000000000000010000010000000011010010000000101000000000000000000000000000000001001000000010100000000000000000000000000000000001010001100000000000000",
		"000000000000000100000000100000010000000010000000000010100000000000000000100000000000000000010011000101000000000100000000000001000000000001000000010100100000000100000000000000011000000000000000",
	};

	static const int N = sizeof(filters) / sizeof(const char *);

	for(int i = 0; i < N; ++i) {
		filter_t f(filters[i]);
		P.add(f, 1, i);
	}

	const char * query_filters[] = {
		"000000000000010000000100000000000000100000001000100000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000001000000000000100000000000000000000000000101001000",
		"100000100000010001000010000000000000100000000000100011000010000010000010011010010000000101010000000000000001100000000000001001000000010100100000000100000010000111000000000111000110000100000010",
		"000000000000010000000000000000000000100000000000100000000010000000000010010000000000000100010000000000000000100000000000000000000000000000100000000100000010000101000000000110000010000100000010",
		"000000000001000000000001000100000000001000000010000000000000000001000000000000000100000000000000000000000000000010100000010000000011000000010000000010000000000000000010000000001000000000101000",
		"100010100111110101100010000000000000100000011111010001111101000001100001001101001000100010101000000000000000110000000000001100100100001010111000000001000011100001110000111000001110000100000010",
		"000010000100100000000000001000000100000000000000000000000000000000000000000101000000000000010000000000000000000000000000001000000100000000101000000000000010000000000000010000000000000000000000",
		"000110000010000100100000000000000000000000010000000000001001000000100000000000000000100010000000000000000000000000000000000000101000000000000011000000001000000000000100000000000001001000000010",
		"011000000010000000000000000000000001000000000000000000000000000000000001000010000000000000001000000000000010000000000010000000000000010000000100000000100000000000000000000000000000101000000000",
		"000010000000010000000000000010010000000000000001000100000000000000000000000000010000000000000000100000000000000000000000000000000000000000001000000000000000000000000000000000000000111000000000",
		"000000000000000000000000000000001100000000000000000100000000000000010000000010001000000000000000000000001000000000000000010000000001100000000000000000000000000000000000000000000100000100100001",
		"000000100000000000000010001010011100000000000001000100000010000010010011001110011000000101000011100000001111000000000000011001000001110100001100000000000000000000000000001010001100111100110001",
		"000000000000000100000000100000010000000010000000000010100000000000000000100000000000000000010011000101000000000100000000000001000000000001000000010100100000000100000000000000011000000000000000",
		"111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111",
	};

	static const int M = sizeof(query_filters) / sizeof(const char *);


	for(int i = 0; i < M; ++i) {
		filter_t qf(query_filters[i]);
		std::set<interface_t> results;
		match_vector handler;

		P.match(qf, handler);

		handler.return_results(results);

		for(int j = 0; j < N; ++j) {
			if (filter_t(filters[j]).subset_of(qf)) {
				BOOST_CHECK(results.count(j) == 1);
				results.erase(j);
			}
		}

		BOOST_CHECK(results.empty());
	}

	for(int i = 0; i < M; ++i) {
		filter_t qf(query_filters[i]);
		std::set<interface_t> results;
		match_vector handler;

		P.match(qf, handler);

		handler.return_results(results);

		for(int j = 0; j < N; ++j) {
			if (filter_t(filters[j]).subset_of(qf)) {
				BOOST_CHECK(results.count(j) == 1);
				results.erase(j);
			}
		}

		BOOST_CHECK(results.empty());
	}
}

BOOST_AUTO_TEST_CASE( deepest_trie ) {
	predicate P;

	filter_t f;			// all-zero

	for(filter_pos_t i = 0; i < filter_t::WIDTH; ++i) {
		f.set_bit(i);
		P.add(f, 1, i);
	}

	std::set<interface_t> results;
	match_vector handler;

	P.match(f, handler);

	handler.return_results(results);

	for(filter_pos_t i = 0; i < filter_t::WIDTH; ++i) {
		BOOST_CHECK(results.count(i) == 1);
		results.erase(i);
	}

	BOOST_CHECK(results.empty());
}

BOOST_AUTO_TEST_SUITE_END()

