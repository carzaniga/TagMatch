// -*- C++ -*-
//
//  This file is part of Siena, a wide-area event notification system.
//  See http://www.inf.usi.ch/carzaniga/siena/
//
//  Authors: Antonio Carzaniga
//  See the file AUTHORS for full details.
//
//  Copyright (C) 2013 Antonio Carzaniga
//
//  Siena is free software: you can redistribute it and/or modify
//  it under the terms of the GNU General Public License as published by
//  the Free Software Foundation, either version 3 of the License, or
//  (at your option) any later version.
//
//  Siena is distributed in the hope that it will be useful,
//  but WITHOUT ANY WARRANTY; without even the implied warranty of
//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//  GNU General Public License for more details.
//
//  You should have received a copy of the GNU General Public License
//  along with Siena.  If not, see <http://www.gnu.org/licenses/>.
//
#include <iostream>
#include <vector>
#include <set>

#include "key.hh"
#include "filter.hh"
#include "partitioning.hh"
#include "fib.hh"

using std::vector;
using std::set;

static const filter_t ALL_ONES("111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111");

static const filter_t ALL_ZEROS("000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000");

static const filter_t F[] = {
	filter_t("000000000000100000001000000000000001000000010001000000000000000000000000000000000000000000000000001000000000000000000000001000000000000000000010000000000001000000000000010000000000001010010001"),
	filter_t("000000000000010000000100000000000000100000001000100000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000001000000000000100000000000001000000000000101001000"),
	filter_t("000000000000010000000000000000000000100000000000100000000010000000000010010000000000000100010000000000000000100000000000000000000000000000100000000100000010000101000000000110000010000100000010"),
	filter_t("000000000001000000000001000100000000001000000010000000000000000001000000000000000100000000000000000000000000000010100000010000000011000000010000000010000000000000000010000000001000000000101000"),
	filter_t("000010000100100000000000001000000100000000000000000000000000000000000000000101000000000000010000000000000000000000000000001000000100000000101000000000000010000000000000010000000000000000000000"),
	filter_t("000110000010000100100000000000000000000000010000000000001001000000100000000000000000100010000000000000000000000000000000000000101000000000000011000000001000000000000100000000000001001000000010"),
	filter_t("011000000010000000000000000000000001000000000000000000000000000000000001000010000000000000001000000000000010000000000010000000000000010000000100000000100000000000000000000000000000101000000000"),
	filter_t("000010000000010000000000000010010000000000000001000100000000000000000000000000010000000000000000100000000000000000000000000000000000000000001000000000000000000000000000000000000000111000000000"),
	filter_t("000000000000000000000000000000001100000000000000000100000000000000010000000010001000000000000000000000001000000000000000010000000001100000000000000000000000000000000000000000000100000100100001"),
	filter_t("100000100000000000000010000000000000000000000000000000000010000010000000011010010000000101000000000000000000000000000000001001000000010100000000000000000000000000000000001010001100000000000000"),
	filter_t("000000000000000100000000100000010000000010000000000010100000000000000000100000000000000000010011000101000000000100000000000001000000000001000000010100100000000100000000000000011000001000000000"),
};

static const filter_t Q[] = {
	filter_t("000000000000010000000100000000000000100000001000100000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000001000000000000100000000000000000000000000101001000"),
	filter_t("100000100000010001000010000000000000100000000000100011000010000010000010011010010000000101010000000000000001100000000000001001000000010100100000000100000010000111000000000111000110000100000010"),
	filter_t("000000000000010000000000000000000000100000000000100000000010000000000010010000000000000100010000000000000000100000000000000000000000000000100000000100000010000101000000000110000010000100000010"),
	filter_t("000000000001000000000001000100000000001000000010000000000000000001000000000000000100000000000000000000000000000010100000010000000011000000010000000010000000000000000010000000001000000000101000"),
	filter_t("100010100111110101100010000000000000100000011111010001111101000001100001001101001000100010101000000000000000110000000000001100100100001010111000000001000011100001110000111000001110000100000010"),
	filter_t("000010000100100000000000001000000100000000000000000000000000000000000000000101000000000000010000000000000000000000000000001000000100000000101000000000000010000000000000010000000000000000000000"),
	filter_t("000110000010000100100000000000000000000000010000000000001001000000100000000000000000100010000000000000000000000000000000000000101000000000000011000000001000000000000100000000000001001000000010"),
	filter_t("011000000010000000000000000000000001000000000000000000000000000000000001000010000000000000001000000000000010000000000010000000000000010000000100000000100000000000000000000000000000101000000000"),
	filter_t("000010000000010000000000000010010000000000000001000100000000000000000000000000010000000000000000100000000000000000000000000000000000000000001000000000000000000000000000000000000000111000000000"),
	filter_t("000000000000000000000000000000001100000000000000000100000000000000010000000010001000000000000000000000001000000000000000010000000001100000000000000000000000000000000000000000000100000100100001"),
	filter_t("000000100000000000000010001010011100000000000001000100000010000010010011001110011000000101000011100000001111000000000000011001000001110100001100000000000000000000000000001010001100111100110001"),
	filter_t("000000000000000100000000100000010000000010000000000010100000000000000000100000000000000000010011000101000000000100000000000001000000000001000000010100100000000100000000000000011000000000000000"),
	filter_t("111111111111111111111111111111111111111011111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111"),
};

static bool find_mask(const vector<partition_prefix> & masks, const filter_t & f) {
	for (const partition_prefix & m : masks)
		if (f == m.filter)
			return true;
	return false;
}

static partition_id_t find_partition_id(const vector<partition_prefix> & masks, const filter_t & f) {
	for (const partition_prefix & m : masks)
		if (f == m.filter)
			return m.partition;
	return NULL_PARTITION_ID;
}

#define BOOST_TEST_MODULE balanced_partitioning
#define BOOST_TEST_DYN_LINK 1

#include <boost/test/unit_test.hpp>

BOOST_AUTO_TEST_SUITE( basics )

BOOST_AUTO_TEST_CASE( set_get_parameters ) {
	partitioning::set_maxp(5);
	BOOST_CHECK(partitioning::get_maxp() == 5);
	partitioning::set_maxp(100000);
	BOOST_CHECK(partitioning::get_maxp() == 100000);

	partitioning::set_cpu_threads(5);
	BOOST_CHECK(partitioning::get_cpu_threads() == 5);
	partitioning::set_cpu_threads(100);
	BOOST_CHECK(partitioning::get_cpu_threads() <= 100);
}

BOOST_AUTO_TEST_SUITE_END()

BOOST_AUTO_TEST_SUITE( do_partitioning )

BOOST_AUTO_TEST_CASE( small_fib_no_part ) {
	vector<partition_fib_entry *> fib;
	vector<tagmatch_key_t> keys = { 0 };

	fib.push_back(new partition_fib_entry(fib_entry(Q[0], keys)));
	fib.push_back(new partition_fib_entry(fib_entry(Q[1], keys)));
	fib.push_back(new partition_fib_entry(fib_entry(Q[2], keys)));

	vector<partition_prefix> masks;

	partitioning::set_maxp(5);
	partitioning::balanced_partitioning(fib, masks);
	BOOST_CHECK(masks.size() == 1);
	for(partition_fib_entry * pfe : fib) {
		BOOST_CHECK(pfe->partition == 0);
		delete(pfe);
	}
}

BOOST_AUTO_TEST_CASE( small_fib_part ) {
	vector<partition_fib_entry *> fib;
	vector<tagmatch_key_t> keys = { 0 };

	fib.push_back(new partition_fib_entry(fib_entry(F[0], keys)));
	fib.push_back(new partition_fib_entry(fib_entry(F[1], keys)));
	fib.push_back(new partition_fib_entry(fib_entry(F[2], keys)));

	vector<partition_prefix> masks;

	partitioning::set_maxp(5);
	partitioning::balanced_partitioning(fib, masks);
	BOOST_REQUIRE(masks.size() == 2);

	filter_t m0(F[0]);
	filter_t m1(F[1]);
	m1 &= F[2];

	BOOST_CHECK((masks[0].filter == m0 && masks[1].filter == m1) || (masks[1].filter == m0 && masks[0].filter == m1));

	for(partition_fib_entry * pfe : fib) {
		BOOST_CHECK(masks[pfe->partition].filter.subset_of(pfe->filter));
		delete(pfe);
	}
}

BOOST_AUTO_TEST_CASE( large_fib_part ) {
	vector<partition_fib_entry *> fib;
	vector<tagmatch_key_t> keys = { 0 };

	for (const filter_t * f = F; f != F + sizeof(F)/sizeof(filter_t); ++f)
		fib.push_back(new partition_fib_entry(fib_entry(*f, keys)));

// "000000000001000000000001000100000000001000000010000000000000000001000000000000000100000000000000000000000000000010100000010000000011000000010000000010000000000000000010000000001000000000101000"  // 3

// "000010000100100000000000001000000100000000000000000000000000000000000000000101000000000000010000000000000000000000000000001000000100000000101000000000000010000000000000010000000000000000000000"  // 4
// "100000100000000000000010000000000000000000000000000000000010000010000000011010010000000101000000000000000000000000000000001001000000010100000000000000000000000000000000001010001100000000000000"  // 9

// "000000000000010000000100000000000000100000001000100000000000000000000000000000000000000000000000000100000000000000000000000100000000000000000001000000000000100000000000001000000000000101001000"  // 1
// "000000000000010000000000000000000000100000000000100000000010000000000010010000000000000100010000000000000000100000000000000000000000000000100000000100000010000101000000000110000010000100000010"  // 2
// "000000000000000000000000000000001100000000000000000100000000000000010000000010001000000000000000000000001000000000000000010000000001100000000000000000000000000000000000000000000100000100100001"  // 8

// "000000000000100000001000000000000001000000010001000000000000000000000000000000000000000000000000001000000000000000000000001000000000000000000010000000000001000000000000010000000000001010010001"  // 0
// "011000000010000000000000000000000001000000000000000000000000000000000001000010000000000000001000000000000010000000000010000000000000010000000100000000100000000000000000000000000000101000000000"  // 6
// "000000000000000100000000100000010000000010000000000010100000000000000000100000000000000000010011000101000000000100000000000001000000000001000000010100100000000100000000000000011000001000000000"  // 10

// "000010000000010000000000000010010000000000000001000100000000000000000000000000010000000000000000100000000000000000000000000000000000000000001000000000000000000000000000000000000000111000000000"  // 7
// "000110000010000100100000000000000000000000010000000000001001000000100000000000000000100010000000000000000000000000000000000000101000000000000011000000001000000000000100000000000001001000000010"  // 5

	vector<partition_prefix> masks;

	partitioning::set_maxp(3);
	partitioning::balanced_partitioning(fib, masks);
	BOOST_CHECK_EQUAL(masks.size(), 5);

	filter_t m3(F[3]);

	BOOST_REQUIRE(find_mask(masks, m3));

	filter_t m49(F[4]);
	m49 &= F[9];

	BOOST_REQUIRE(find_mask(masks, m49));

	filter_t m128(F[1]);
	m128 &= F[2];
	m128 &= F[8];

	BOOST_REQUIRE(find_mask(masks, m128));

	partition_id_t p3 = find_partition_id(masks, m3);
	partition_id_t p49 = find_partition_id(masks, m49);
	partition_id_t p128 = find_partition_id(masks, m128);

	for(partition_fib_entry * pfe : fib) {
		if (pfe->filter == F[3])
			BOOST_CHECK(pfe->partition == p3);
		else if (pfe->filter == F[4])
			BOOST_CHECK(pfe->partition == p49);
		else if (pfe->filter == F[9])
			BOOST_CHECK(pfe->partition == p49);
		else if (pfe->filter == F[1])
			BOOST_CHECK(pfe->partition == p128);
		else if (pfe->filter == F[2])
			BOOST_CHECK(pfe->partition == p128);
		else if (pfe->filter == F[8])
			BOOST_CHECK(pfe->partition == p128);
		delete(pfe);
	}
}

BOOST_AUTO_TEST_CASE( large_fib_permutation ) {
	vector<partition_fib_entry *> fib;
	vector<tagmatch_key_t> keys = { 0 };

	set<partition_fib_entry *> all_before;
	set<partition_fib_entry *> all_after;

	for (const filter_t * f = F; f != F + sizeof(F)/sizeof(filter_t); ++f)
		fib.push_back(new partition_fib_entry(fib_entry(*f, keys)));

	for (const filter_t * f = Q; f != Q + sizeof(Q)/sizeof(filter_t); ++f)
		fib.push_back(new partition_fib_entry(fib_entry(*f, keys)));

	for (partition_fib_entry * pfe : fib)
		all_before.insert(pfe);

	vector<partition_prefix> masks;

	partitioning::set_maxp(4);
	partitioning::balanced_partitioning(fib, masks);

	for (partition_fib_entry * pfe : fib) {
		all_after.insert(pfe);
		BOOST_CHECK(masks[pfe->partition].filter.subset_of(pfe->filter));
	}
	BOOST_CHECK(all_before == all_after);

	for (partition_fib_entry * pfe : fib)
		delete(pfe);
}

BOOST_AUTO_TEST_SUITE_END()
